var documenterSearchIndex = {"docs":
[{"location":"library/function_index/#Function-index","page":"Function index","title":"Function index","text":"","category":"section"},{"location":"library/function_index/#ovc_func_index","page":"Function index","title":"OceanVariableConversions","text":"","category":"section"},{"location":"library/function_index/#OceanVariableConversions-exported-functions","page":"Function index","title":"OceanVariableConversions exported functions","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Modules = [OceanVariableConversions]\nPrivate = false","category":"page"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions","text":"Module to convert variables depth, practical salinity and potential temperature to the TEOS-10 standard variables pressure, absolute salinity and conservative temperature (respectively) from a Raster, RasterStack  or RasterSeries. A few chosen seawater variables can then be computed from these state variables.\n\n\n\n\n\n","category":"module"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.Sₚ_to_Sₐ-Tuple{Rasters.Raster, Rasters.Raster, Tuple, Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.Sₚ_to_Sₐ","text":"function Sₚ_to_Sₐ(Sₚ::Raster)\nfunction Sₚ_to_Sₐ(stack::RasterStack, Sₚ::Symbol)\nfunction Sₚ_to_Sₐ(series::RasterSeries, Sₚ::Symbol)\n\nConvert a Raster of practical salinity (Sₚ) to absolute salinity (Sₐ) using gsw_sa_from_sp from GibbsSeaWater.jl. This conversion depends on pressure. If converting from a RasterStack or RasterSeries, the symbol for the practical salinity in the RasterStack/Series must be passed in as a Symbol –-  that is if the variable name is SALT the RasterStack/Series, the Symbol :SALT must be passed in.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.convert_ocean_vars-Tuple{Rasters.RasterStack, NamedTuple}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.convert_ocean_vars","text":"function convert_ocean_vars(raster::RasterStack, var_names::NamedTuple;\n                            ref_pressure = nothing,\n                            with_α = false,\n                            with_β = false)\nfunction convert_ocean_vars(raster::Rasterseries, var_names::NamedTuple;\n                            ref_pressure = nothing,\n                            with_α = false,\n                            with_β = false)\n\nConvert ocean variables depth, practical salinity and potential temperature to pressure, absolute salinity and conservative temperature. All conversions are done using the julia implementation of TEOS-10 GibbsSeaWater.jl. A new Raster is returned that contains the variables pressure, absolute salinity, conservative temperature and density (either in-situ or referenced to a user defined reference pressure). As pressure depends on latitude and depth, it is added as a new variable –- that is, each longitude, latitude, depth and time have a variable for pressure. A density variable is also computed which, by default, is in-situ density. Potential density at a reference pressure can be computed instead by passing a the keyword argument ref_pressure. Optional keyword arguments with_α and with_β allow the thermal expansion and haline contraction coefficients (respectively) to be computed and added to the returned RasterStack/Series.\n\nThe name of the variables for potential temperature and practical salinity must be passed in as a NamedTuple of the form (Sₚ = :salt_name, θ = :potential_temp_name) where :potential_temp_name and :salt_name are the name of the potential temperature and practical salinity in the Raster.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.depth_to_pressure-Tuple{Rasters.Raster, Tuple}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.depth_to_pressure","text":"function depth_to_pressure(raster::Raster)\nfunction depth_to_pressure(stack::RasterStack)\n\nConvert the depth dimension (Z) to pressure using gsw_p_from_z  from GibbsSeaWater.jl. Note that pressure depends on depth and latitude so the returned pressure is stored as a variable in the resulting Raster rather than replacing the vertical depth dimension.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.get_α-NTuple{4, Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.get_α","text":"function get_α(Sₐ::Raster, Θ::Raster, p::Raster)\nfunction get_α(stack::RasterStack, var_names::NamedTuple)\nfunction get_α(series::RasterSeries, var_names::NamedTuple)\n\nCompute the thermal exapnsion coefficient, α, using gsw_alpha from GibbsSeaWater.jl. To compute α from a RasterStack or RasterSeries the variable names must be passed into the function as a NamedTuple in the form (Sₐ = :salt_var, Θ = :temp_var, p = :pressure_var). The returned Raster will have the same dimensions as Rasterstack that is passed in.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.get_β-NTuple{4, Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.get_β","text":"function get_β(Sₐ::Raster, Θ::Raster, p::Raster)\nfunction get_β(stack::RasterStack, var_names::NamedTuple)\nfunction get_β(series::RasterSeries, var_names::NamedTuple)\n\nCompute the haline contraction coefficient, β, using gsw_beta from GibbsSeaWater.jl. To compute β from a RasterStack or RasterSeries the variable names must be passed into the function as a NamedTuple in the form (Sₐ = :salt_var, Θ = :temp_var, p = :pressure_var). The returned Raster will have the same dimensions as Rasterstack that is passed in.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.get_ρ-NTuple{4, Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.get_ρ","text":"function get_ρ(Sₐ::Raster, Θ::Raster, p::Raster)\nfunction get_ρ(stack::RasterStack, var_names::NamedTuple)\nfunction get_ρ(series::RasterStack, var_names::NamedTuple)\n\nCompute in-situ density, ρ, using gsw_rho from GibbsSeaWater.jl. This computation depends on absolute salinity (Sₐ), conservative temperature (Θ) and pressure (p). To compute ρ from a RasterStack or RasterSeries the variable names must be passed into the function as a NamedTuple in the form (Sₐ = :salt_var, Θ = :temp_var, p = :pressure_var). The returned Raster will have the same dimensions as Rasterstack that is passed in.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.get_σₚ-Tuple{Rasters.Raster, Rasters.Raster, Number, Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.get_σₚ","text":"function get_σₚ(Sₐ::Raster, Θ::Raster, p::Number)\nfunction get_σₚ(stack::RasterStack, var_names::NamedTuple)\nfunction get_σₚ(series::RasterStack, var_names::NamedTuple)\n\nCompute potential density at reference pressure p, σₚ, using gsw_rho from GibbsSeaWater.jl. This computation depends on absolute salinity (Sₐ), conservative temperature (Θ) and a user entered reference pressure (p). Compute and return the potential density σₚ at reference pressure p from a RasterStack or RasterSeries. This computation depends on absolute salinity Sₐ, conservative temperature Θ and a reference pressure p. The variable names must be passed into the function as a NamedTuple in the form (Sₐ = :salt_var, Θ = :temp_var, p = ref_pressure). Note p in this case is a number. The returned Raster will have the same dimensions as Rasterstack that is passed in.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.θ_to_Θ-Tuple{Rasters.Raster, Rasters.Raster, Tuple, Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.θ_to_Θ","text":"function θ_to_Θ(θ::Raster, Sₐ::Raster)\nfunction θ_to_Θ(stack::RasterStack, var_names::NamedTuple)\nfunction θ_to_Θ(series::RasterSeries, var_names::NamedTuple)\n\nConvert a Raster of potential temperature (θ) to conservative temperature (Θ) using gsw_ct_from_pt  from GibbsSeaWater.jl. This conversion depends on absolute salinity. If converting from a  from a RasterStack or a RasterSeries, the var_names must be passed in as for convert_ocean_vars –-  that is, as a named tuple in the form (Sₚ = :salt_name, θ = :potential_temp_name) where :potential_temp_name and :salt_name are the name of the potential temperature and salinity in the RasterStack.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanVariableConversions-private-functions","page":"Function index","title":"OceanVariableConversions private functions","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Modules = [OceanVariableConversions]\nPublic = false","category":"page"},{"location":"library/function_index/#OceanRasterConversions.OceanVariableConversions.get_dims-Tuple{Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.OceanVariableConversions.get_dims","text":"function get_dims(raster::Raster)\n\nGet the dimensions of a Raster.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#rh_func_index","page":"Function index","title":"RasterHistograms","text":"","category":"section"},{"location":"library/function_index/#RasterHistograms-exported-functions","page":"Function index","title":"RasterHistograms exported functions","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Modules = [RasterHistograms]\nPrivate = false","category":"page"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms","page":"Function index","title":"OceanRasterConversions.RasterHistograms","text":"Module to fit Histograms to data that is saved as a Raster, RasterStack or RasterSeries. The fitted Histogram will be N-dimensional, where N is the number of layers (i.e. variables) to fit the Histogram to. The Histogram is fitted to the Raster data using the StatsBase.jl] empirical estimation module. For more information on how the Histogram is fitted to the data, and the arguments see the StatsBase.jl documentation.\n\n\n\n\n\n","category":"module"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.RasterLayerHistogram","page":"Function index","title":"OceanRasterConversions.RasterHistograms.RasterLayerHistogram","text":"mutable struct RasterLayerHistogram <: AbstractRasterHistogram\n\nA RasterLayerHistogram. The struct is mutable so that the histogram field can be updated using the normalize (or otherwise) function.\n\nlayer::Symbol: The layer (variable) from the Raster\ndimensions::Tuple: The dimensions of the Raster\nraster_size::Tuple: The size of the Raster\nhistogram::StatsBase.AbstractHistogram: The 1-dimensional histogram fitted to the Raster layer data\n\n\n\n\n\n","category":"type"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.RasterLayerHistogram-Tuple{Rasters.Raster}","page":"Function index","title":"OceanRasterConversions.RasterHistograms.RasterLayerHistogram","text":"function RasterLayerHistogram(rs::Raster; closed = :left, nbins = nothing)\nfunction RasterLayerHistogram(rs::Raster, weights::AbstractWeights;\n                              closed = :left, nbins = nothing)\nfunction RasterLayerHistogram(rs::Raster, edges::AbstractVector; closed = :left)\nfunction RasterLayerHistogram(rs::Raster, weights::AbstractWeights,\n                              edges::AbstractVector; closed = :left)\n\nConstruct a RasterLayerHistogram from a Raster. The flattened Raster data, with the missing values removed, is passed to the fit(::Histogram) function from StatsBase.jl and a RasterLayerHistogram type is returned.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.RasterSeriesHistogram","page":"Function index","title":"OceanRasterConversions.RasterHistograms.RasterSeriesHistogram","text":"mutable struct RasterSeriesHistogram <: AbstractRasterHistogram\n\nA RasterSeriesHistogram. The struct is mutable so that the histogram field can be updated using the normalize (or otherwise) function.\n\nlayers::Tuple: The layers (variables) from the RasterSeries used to fit the Histogram\nseries_dimension::Symbol: The dimension of the RasterSeries (usually this will be time)\nseries_length::Int64: The length of the `RasterSeries\ndimensions::Tuple: The dimensions of the elements (either a Raster or RasterStack) of the RasterSeries\nraster_size::Tuple: The size of the elements (either a Raster or RasterStack) of the RasterSeries\nhistogram::StatsBase.Histogram: The N-dimensional Histogram fitted to the N layers from RasterSeries\n\n\n\n\n\n","category":"type"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.RasterSeriesHistogram-Union{Tuple{N}, Tuple{Rasters.RasterSeries, Tuple{Vararg{AbstractVector, N}}}} where N","page":"Function index","title":"OceanRasterConversions.RasterHistograms.RasterSeriesHistogram","text":"function RasterSeriesHistogram(series::RasterSeries, edges::NTuple{N, AbstractVector};\n                               closed = :left)\nfunction RasterSeriesHistogram(series::RasterSeries, weights::AbstractWeights,\n                               edges::NTuple{N, AbstractVector}; closed = :left)\n\nConstruct a RasterSeriesHistogram from a RasterSeries. Note that to merge Histograms the bin edges must be the same, so for this constructor the edges must be passed in. This constructor assumes that the dimensions are the same across all RasterStacks in the RasterSeries.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.RasterStackHistogram","page":"Function index","title":"OceanRasterConversions.RasterHistograms.RasterStackHistogram","text":"mutable struct RasterStackHistogram <: AbstractRasterHistogram\n\nA RasterStackHistogram. The struct is mutable so that the histogram field can be updated using the normalize (or otherwise) function.\n\nlayers::Tuple: The layers (variables) from the RasterStack used to fit the Histogram\ndimensions::Tuple: The dimensions of the RasterStack\nraster_size::Tuple: The size of the RasterStack layers\nhistogram::StatsBase.Histogram: The N-dimensional Histogram fitted to the N layers from RasterStack\n\n\n\n\n\n","category":"type"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.RasterStackHistogram-Tuple{Rasters.RasterStack}","page":"Function index","title":"OceanRasterConversions.RasterHistograms.RasterStackHistogram","text":"function RasterStackHistogram(stack::RasterStack; closed = :left, nbins = nothing)\nfunction RasterStackHistogram(stack::RasterStack, weights::AbstractWeights;\n                              closed = :left, nbins = nothing)\nfunction RasterStackHistogram(stack::RasterStack, edges::NTuple{N, AbstractVector};\n                              closed = :left)\nfunction RasterStackHistogram(stack::RasterStack, weights::AbstractWeights,\n                              edges::NTuple{N, AbstractVector}; closed = :left)\n\nConstruct a RasterStackHistogram from a RasterStack. The resulting Histogram is N-dimensional, where N is the number of layers. The flattened Raster data for each layer, with themissing values removed, is passed to the fit(::Histogram) function from StatsBase.jl and a RasterStackHistogram type is returned.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#LinearAlgebra.normalize!-Tuple{OceanRasterConversions.RasterHistograms.AbstractRasterHistogram}","page":"Function index","title":"LinearAlgebra.normalize!","text":"function normalize!(arh::AbstractRasterHistogram; mode::Symbol = :pdf)\n\nNormalize the Histogram in the AbstractRasterHistogram according the desired mode. See the StatsBase.jl docs for information on the possible modes and how they work.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#MakieCore.convert_arguments","page":"Function index","title":"MakieCore.convert_arguments","text":"function convert_arguments(P::Type{<:AbstractPlot}, arh::AbstractRasterHistogram)\n\nConverting method so Makie.jl can plot an AbstractRasterHistogram. Note for plotting purposes a value correspnding to zero is replaced with NaN. This is to avoid in 2D plotting many zero values and as a result not seeing the distribtution clearly (in Makie.kj heatmap the NaN value is left out in plotting).\n\n\n\n\n\n","category":"function"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.area_weights-Tuple{Union{Rasters.Raster, Rasters.RasterStack}}","page":"Function index","title":"OceanRasterConversions.RasterHistograms.area_weights","text":"function area_weights(rs::Union{Raster, RasterStack}; equator_one_degree = 111e3)\n\nReturn the Weights for a Histogram calculated from the area of each grid cell in a Raster or RasterStack. The Raster or RasterStack must first be sliced over the dimensions one wishes to look at, e.g. for area weights at sea surface the function need rs[Z(1)] to be passed in. If the original Raster only has two spatial dimensions then this step may be skipped. The keyword argument equator_one_degree is one degree at the equator in metres. The function returns a container Weights so can be passed straight into the fit(::Histogram) function.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.volume_weights-Tuple{Union{Rasters.Raster, Rasters.RasterStack}}","page":"Function index","title":"OceanRasterConversions.RasterHistograms.volume_weights","text":"function volume_weights(rs::Union{Raster, RasterStack}; equator_one_degree = 111e3)\n\nReturn the Weights for a Histogram calculated from the volume of each grid cell in a Raster or RasterStack. The model resolution is inferred from the X and Y dimensions of the Raster or RasterStack and assumes that along the X and Y the resolution is unique (though it can be different for X and Y). The keyword argument equator_one_degree is one degree at the equator in metres. The function returns a container Weights so can be passed straight into the fit(::Histogram) function.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#RasterHistograms-private-functions","page":"Function index","title":"RasterHistograms private functions","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Modules = [RasterHistograms]\nPublic = false","category":"page"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.AbstractRasterHistogram","page":"Function index","title":"OceanRasterConversions.RasterHistograms.AbstractRasterHistogram","text":"Abstract supertype for a RasterHistogram.\n\n\n\n\n\n","category":"type"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.find_stack_non_missing-Tuple{Rasters.RasterStack}","page":"Function index","title":"OceanRasterConversions.RasterHistograms.find_stack_non_missing","text":"function find_stack_non_missing(stack::RasterStack)\n\nReturn a Raster of type Bool that contains the intersection of the non-missing values from the layers of a RasterStack.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#OceanRasterConversions.RasterHistograms.raster_zeros_to_nan-Tuple{OceanRasterConversions.RasterHistograms.AbstractRasterHistogram}","page":"Function index","title":"OceanRasterConversions.RasterHistograms.raster_zeros_to_nan","text":"function raster_zeros_to_nan(arh::AbstractRasterHistogram)\n\nConvert the zeros (i.e. empty bins in the AbstractRasterHistogram) to NaNs for plotting in Makie.\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Type{<:OceanRasterConversions.RasterHistograms.AbstractRasterHistogram}, OceanRasterConversions.RasterHistograms.AbstractRasterHistogram}","page":"Function index","title":"RecipesBase.apply_recipe","text":"Conversion method for plotting in Plots.jl\n\n\n\n\n\n","category":"method"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"EditURL = \"https://github.com/jbisits/OceanRasterConversions.jl/blob/main/examples/raster_histograms.jl\"","category":"page"},{"location":"literated/raster_histograms/#raster_hist_example","page":"Histograms from Rasters","title":"Raster Histograms","text":"","category":"section"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"First, add the required depedencies","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"using Rasters, NCDatasets, Downloads, CairoMakie","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"and the RasterHistograms module from OceanRasterConversions.jl package","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"using OceanRasterConversions.RasterHistograms","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"Using this module we can produce Histograms from data that is in a Raster, RasterStack or RasterSeries, which are N-dimensional arrays, in a similar way that xhistogram works for xarray in python. This example is structured similarly to the xhistogram tutorial.","category":"page"},{"location":"literated/raster_histograms/#Randomly-generated-toy-data","page":"Histograms from Rasters","title":"Randomly generated toy data","text":"","category":"section"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"First we generate some randomly distributed data and form a Raster.","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"x, t = range(-2π, 2π; length = 50), range(0, 4π; length = 100)\ndimensions = (X(x), Ti(t))\nrs = Raster(randn(length(x), length(t)), dimensions; name = :Toy_data)","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"The we can form a RasterLayerHistogram for the :Toy_data","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"rs_hist = RasterLayerHistogram(rs)","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"We can then plot the data and the Histogram","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"fig = Figure(size = (1000, 600))\nax1 = Axis(fig[1, 1];\n           title = \"Toy data\",\n           xlabel = \"x\",\n           ylabel = \"time\")\nhm = heatmap!(ax1, x, t, rs.data)\nColorbar(fig[2, 1], hm; vertical = false, flipaxis = false)\nax2 = Axis(fig[1, 2];\n          title = \"Histogram of Toy data\",\n          xlabel = \"Toy data\", ylabel = \"Counts\")\nplot!(ax2, rs_hist; color = :steelblue)\nfig","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"By default the Histogram has the counts in each bin. We can normalise the Histogram by calling the normalize! function on rs_hist and choosing a mode of normalisation. For more information about the possible modes of normalisation see here.","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"normalize!(rs_hist; mode = :pdf)","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"Then replot with the normalised histogram","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"fig = Figure(size = (900, 600))\nax1 = Axis(fig[1, 1];\n           title = \"Toy data\",\n           xlabel = \"x\",\n           ylabel = \"time\")\nhm = heatmap!(ax1, x, t, rs.data)\nColorbar(fig[2, 1], hm; vertical = false, flipaxis = false)\nax2 = Axis(fig[1, 2];\n          title = \"Histogram (pdf) of Toy data\",\n          xlabel = \"Toy data\", ylabel = \"density\")\nplot!(ax2, rs_hist; color = :steelblue)\nfig","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"info: Info\nPlotting using Plots.jl is also possible. See the module documentation for more info.","category":"page"},{"location":"literated/raster_histograms/#Real-world-data-example","page":"Histograms from Rasters","title":"Real world data example","text":"","category":"section"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"This package is mainly concerned with ocean variables, so we now look at temperature and salinity distributions from the same ECCO temperature and salinity data we look at in the converting ocean variables example. This example also shows how the module works for 2-dimensional Histograms though it can be generalised to N dimensions depending on the number of variables (i.e. layers in the RasterStack) one is looking at.","category":"page"},{"location":"literated/raster_histograms/#Forming-the-RasterStack","page":"Histograms from Rasters","title":"Forming the RasterStack","text":"","category":"section"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"We form a RasterStack with only the :SALT (practical salinity) and :THETA (potential temperature) layers. This means the resulting RasterStackHistogram will be 2 dimensional. Note the order of the variables matters here for plotting purposes. The first layer, in this case :SALT will be the x-axis, and the second layer :THETA will be the y-axis.","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"stack_TS = RasterStack(\"ECCO_data.nc\"; name = (:SALT, :THETA))\nedges = (31:0.025:38, -2:0.1:32)\nstack_hist = RasterStackHistogram(stack_TS, edges)","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"Now we can plot, the histogram and look at the unweighted distribtution of temperature and salinity. By default the empty bins are plotted with the value of zero. To not plot the empty bins argument we pass show_empty_bins = false to the plotting function.","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"fig = Figure(size = (500, 500))\nax = Axis(fig[1, 1];\n          title = \"Temperature and salinity joint distribution (unweighted)\",\n          xlabel = \"Practical salinity (psu)\",\n          ylabel = \"Potential temperature (°C)\")\nshow_empty_bins = false\nhm = heatmap!(ax, stack_hist, show_empty_bins)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"Currently there is no log10 colourscale for a heatmap in Makie.jl (though it looks like it will be here soon) so to view the data on a log10 scale we can extract the data from the stack_hist.histogram, transform the weights and then plot","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"fig = Figure(size = (500, 500))\nax = Axis(fig[1, 1];\n          title = \"Temperature and salinity joint distribution (unweighted, log10 colourscale)\",\n          xlabel = \"Practical salinity (psu)\",\n          ylabel = \"Potential temperature (°C)\")\nhm = heatmap!(ax, stack_hist.histogram.edges..., log10.(stack_hist.histogram.weights);\n              colorrange = (0, 5),\n              lowclip = :white)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"literated/raster_histograms/#Weighting-the-Histogram","page":"Histograms from Rasters","title":"Weighting the Histogram","text":"","category":"section"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"The module also exports simple functions for calculating area and volume weights from the dimensions of the grid and plot the data. Where weights are available from model data they should be used in favour of the functions.","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"dV = volume_weights(stack_TS)\nweighted_stack_hist = RasterStackHistogram(stack_TS, dV, edges)\nfig = Figure(size = (500, 500))\nax = Axis(fig[1, 1];\n          title = \"Temperature and salinity joint distribution (weighted)\",\n          xlabel = \"Practical salinity (psu)\",\n          ylabel = \"Potential temperature (°C)\")\nhm = heatmap!(ax, weighted_stack_hist, show_empty_bins)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"Again to view on a log10 scale we extract the data and transform","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"fig = Figure(size = (500, 500))\nax = Axis(fig[1, 1];\n          title = \"Temperature and salinity joint distribution (weighted by volume, log10 colourscale)\",\n          xlabel = \"Practical salinity (psu)\",\n          ylabel = \"Potential temperature (°C)\")\nhm = heatmap!(ax, weighted_stack_hist.histogram.edges...,\n              log10.(weighted_stack_hist.histogram.weights);\n              colorrange = (11, 16),\n              lowclip = :white)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"","category":"page"},{"location":"literated/raster_histograms/","page":"Histograms from Rasters","title":"Histograms from Rasters","text":"This page was generated using Literate.jl.","category":"page"},{"location":"modules/OceanVariableConversions/#ocean_conv_vars_module","page":"OceanVariableConversions","title":"OceanVarbiableConversion","text":"","category":"section"},{"location":"modules/OceanVariableConversions/#Overview","page":"OceanVariableConversions","title":"Overview","text":"","category":"section"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"This module converts and computes ocean varaibles that are saved as Raster data structures using GibbsSeaWater.jl. Typically, the salt and temperature variables from ocean models or observational data are practical salinity and potential temperature so conversions must be to the TEOS-10 standard variables of absolute salinity and conservative temperature to accurately calculate further variables like seawater density.","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"Further conversions and other water mass transformation procedures will be added in the future.","category":"page"},{"location":"modules/OceanVariableConversions/#Module-workings","page":"OceanVariableConversions","title":"Module workings","text":"","category":"section"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"This module will convert the variables practical salinity and potential temperature into absolute salinity and conservative temperature. In doing so a pressure variable is needed, so this is created and returned in the RasterStack. A density variable (either in-situ or potential referenced to a user input) is computed and added to the RasterStack. See the example for how the module can be used.","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"info: Info\nThe only dimension names that are supported are X, Y, Z, and Ti. Allowing for user specified dimensions has not yet been implemented.","category":"page"},{"location":"modules/OceanVariableConversions/#Variables","page":"OceanVariableConversions","title":"Variables","text":"","category":"section"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"The variables are named using the symbols that represent them. The symbols are unicode characters which can be generated in the julia repl by pressing tab after the varible","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"julia> \\theta#press tab","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"will autocomplete to θ, the symbol for potential temperature. The subscript letters that are used to distinguish between practical salinity, Sₚ, and absolute salinity, Sₐ, are also added in the julia repl","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"julia> S\\_a#press tab","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"Currently the varabile symbols are:","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"θ potential temperature\nΘ conservative temperature\nSₚ practical salinity\nSₐ absolute salinity\np pressure\nρ in-situ seawater density\nσₚ potential density at user defined reference pressure ₚ\nα thermal expansion coefficient\nβ haline contraction coefficient.","category":"page"},{"location":"modules/OceanVariableConversions/#Limitations","page":"OceanVariableConversions","title":"Limitations","text":"","category":"section"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"If the required dimensions for the conversions are not present an error will be thrown. For example, trying to convert a RasterStack that has no depth dimension will not work as the Z dimension is not found and the pressure variable depends on depth. There is a manual workaround for this. When defining the RasterStack add the Z dimension as a single entry, rather than a Vector,","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"lons, lats, z = -180:180, -90:90, 0.0\nstack = RasterStack(data, (X(lons), Y(lats), Z(z)))","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"This is equivalent to a two dimensional RasterStack at sea-surface height (z = 0).","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"At this stage it is also not possible to slice a Raster then convert it. This is something that will be implemented at some stage. For details on why this is the case see this issue. As the example shows it is straightforward to first convert a Raster and then slice it.","category":"page"},{"location":"modules/OceanVariableConversions/","page":"OceanVariableConversions","title":"OceanVariableConversions","text":"For a full list of the functions in this module see the function index or look at the example to see the module in action.","category":"page"},{"location":"modules/RasterHistograms/#raster_hist_module","page":"RasterHistograms","title":"RasterHistograms","text":"","category":"section"},{"location":"modules/RasterHistograms/#Overview","page":"RasterHistograms","title":"Overview","text":"","category":"section"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"This module uses empirical estimation from StatsBase.jl to fit Histograms to Raster, RasterStack or RasterSeries data structures. Arguments that can be passed to fit(::Histogram) can be passed to the constructors for the the various AbstractRasterHistograms. The aim of the module is to provide functionality similar to python's xhistogram for xarray in Julia.","category":"page"},{"location":"modules/RasterHistograms/#Module-workings","page":"RasterHistograms","title":"Module workings","text":"","category":"section"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"For a single Raster (i.e. one variable)","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"DocTestSetup = quote\n    using Rasters, OceanRasterConversions.RasterHistograms\nend","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"julia> dummy_data = repeat(1:10; outer = (1, 10));\n\njulia> rs = Raster(dummy_data, (X(1:10), Ti(1:10)); name = :dummy_variable);\n\njulia> rs_hist = RasterLayerHistogram(rs)\nRasterLayerHistogram for the variable dummy_variable\n ┣━━ Layer dimensions: (:X, :Ti) \n ┣━━━━━━━━ Layer size: (10, 10)\n ┗━━━━━━━━━ Histogram: 1-dimensional\n\njulia> rs_hist.histogram\nStatsBase.Histogram{Int64, 1, Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}}\nedges:\n  0.0:2.0:12.0\nweights: [10, 20, 20, 20, 20, 10]\nclosed: left\nisdensity: false\n","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"a one dimensional Histogram that has been fit to the dumy_variable data is returned in the rs_hist.histogram field as well as some information about the data the Histogram was fit to. If a RasterStack or RasterSeries with multiple layers is passed in the default behaviour is to fit an N-dimensional Histogram where N is the number of layers (i.e. the number of variables).","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"julia> vars = (v1 = randn(10, 10), v2 = randn(10, 10), v3 = randn(10, 10));\n\njulia> stack = RasterStack(vars, (X(1:10), Y(1:10)))\nRasterStack with dimensions: \n  X Sampled{Int64} 1:10 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 1:10 ForwardOrdered Regular Points\nand 3 layers:\n  :v1 Float64 dims: X, Y (10×10)\n  :v2 Float64 dims: X, Y (10×10)\n  :v3 Float64 dims: X, Y (10×10)\n\n\njulia> RasterStackHistogram(stack)\nRasterStackHistogram for the variables (:v1, :v2, :v3)\n ┣━━ Stack dimensions: (:X, :Y)\n ┣━━ Stack layer size: (10, 10)\n ┗━━━━━━━━━ Histogram: 3-dimensional\n","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"info: Info\nThe order of the variables for the Histogram is the order of the layers in the RasterStack or RasterSeries. This can be important for plotting when variables are desired to be on specific axes. In the example above v1 would be on the x-axis, v2 the y-axis and v3 the z-axis. To change which axes the variables correspond to, the order of the layers in the RasterStack would need to be altered (or you could plot from the histogram.weights matrix).","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"DocTestSetup = nothing","category":"page"},{"location":"modules/RasterHistograms/#Plotting","page":"RasterHistograms","title":"Plotting","text":"","category":"section"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"Both Makie.jl and Plots.jl have functions in the module to extract the Histogram object from the AbstractRasterHistogram for plotting. To plot in either package one can just call","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"julia> using #Plotting package e.g. CairoMakie.jl or PLots.jl \n\njulia> plot(::AbstractRasterHistogram)","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"and an N-dimensional Histogram will be plotted where N is the dimension of the ::AbstractRasterHistogram. Makie.jl is used in the exmaple.","category":"page"},{"location":"modules/RasterHistograms/","page":"RasterHistograms","title":"RasterHistograms","text":"For a full list of the functions in this module see the function index or look at the example to see the module in action.","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"EditURL = \"https://github.com/jbisits/OceanRasterConversions.jl/blob/main/examples/ocean_variable_conversion.jl\"","category":"page"},{"location":"literated/ocean_variable_conversion/#converting_variables_example","page":"Converting ocean variables","title":"Converting the practical salinity and potential temperature from ECCOv4r4 model output.","text":"","category":"section"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"First, add the required dependencies","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"using Rasters, NCDatasets, Plots, Downloads\nusing OceanRasterConversions.OceanVariableConversions","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"and download model output from ECCOv4r4. This data is the daily average 0.5 degree salinity and temperature model output. To reproduce this example, an Earthdata acount is needed to download the data.","category":"page"},{"location":"literated/ocean_variable_conversion/#Read-the-data-into-a-RasterStack","page":"Converting ocean variables","title":"Read the data into a RasterStack","text":"","category":"section"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"Downloads.download(\"https://opendap.earthdata.nasa.gov/providers/POCLOUD/collections/ECCO%2520Ocean%2520Temperature%2520and%2520Salinity%2520-%2520Daily%2520Mean%25200.5%2520Degree%2520(Version%25204%2520Release%25204)/granules/OCEAN_TEMPERATURE_SALINITY_day_mean_2007-01-01_ECCO_V4r4_latlon_0p50deg.dap.nc4\", \"ECCO_data.nc\")\n\nstack = RasterStack(\"ECCO_data.nc\")","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"Thanks to Rasters.jl we now have the dimensions of the data, the variables saved as layers and all the metadata in one data structure. From the metadata we can get a summary of the data which tells us more about the data","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"metadata(stack)[\"summary\"]","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"This tells us that the temperature variable is potential temperature and the salt variabile is practical salinity (for more information about this data see the user guide).","category":"page"},{"location":"literated/ocean_variable_conversion/#Converting-all-variables-and-plotting","page":"Converting ocean variables","title":"Converting all variables and plotting","text":"","category":"section"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"To calculate seawater density using TEOS-10, we require absolute salinity, conservative temperature and pressure. This can be done by extracting the data and using GibbsSeaWater.jl or with this package,","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"converted_stack = convert_ocean_vars(stack, (Sₚ = :SALT, θ = :THETA))","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"Note that this is a new RasterStack, so the metadata from the original RasterStack is not attached. As we have a returned RasterStack and plotting recipes have been written, we can, for example, look at the conservative temperature closest to the sea-surface (-5.0m)","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"contourf(converted_stack[:Θ][Z(Near(0.0)), Ti(1)]; size = (800, 500),\n         color = :balance, colorbar_title = \"ᵒC\")","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"We can also take slices of the data to look at depth-latitude plots of the returned variables (note by default the in-situ density ρ is computed and returned)","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"lon = 180\nvar_plots = plot(; layout = (4, 1), size = (1000, 1000))\nfor (i, key) ∈ enumerate(keys(converted_stack))\n    contourf!(var_plots[i], converted_stack[key][X(Near(lon))])\nend\nvar_plots","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"As this is a RasterStack all methods exported by Rasters.jl will work. See the documentation for Rasters.jl for more information.","category":"page"},{"location":"literated/ocean_variable_conversion/#Converting-chosen-variables","page":"Converting ocean variables","title":"Converting chosen variables","text":"","category":"section"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"It is also possible to convert only chosen variables from a RasterStack. If we just want to look at conservative temperature - absolute salinity vertical profiles, we can convert the practical salinity and potential temperature then extract vertical profiles and compute the potential density referenced to 0dbar","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"Sₐ = Sₚ_to_Sₐ(stack, :SALT)\nΘ = θ_to_Θ(stack, (Sₚ = :SALT, θ = :THETA))\nlon, lat = -100.0, -70.0\nSₐ_profile, Θ_profile = Sₐ[X(Near(lon)), Y(Near(lat)), Ti(1)],\n                         Θ[X(Near(lon)), Y(Near(lat)), Ti(1)]\nσ₀_profile = get_σₚ(Sₐ_profile, Θ_profile, 0)\nprofile_plots = plot(; layout = (2, 2), size = (800, 800))\nplot!(profile_plots[1, 1], Sₐ_profile;\n      title = \"Sₐ-depth\", xmirror = true, xlabel = \"Sₐ (g/kg)\")\nplot!(profile_plots[1, 2], Θ_profile;\n      title = \"Θ-depth\", xmirror = true, xlabel = \"Θ (ᵒC)\")\nplot!(profile_plots[2, 1], Sₐ_profile, Θ_profile;\n      xlabel = \"Sₐ (g/kg)\", ylabel = \"Θ (ᵒC)\", label = false, title = \"Sₐ-Θ\")\nplot!(profile_plots[2, 2], σ₀_profile;\n      title = \"σ₀-depth\", xmirror = true, xlabel = \"σ₀ (kgm⁻³)\")","category":"page"},{"location":"literated/ocean_variable_conversion/#Plotting-with-[GeoMakie.jl](https://github.com/MakieOrg/GeoMakie.jl)","page":"Converting ocean variables","title":"Plotting with GeoMakie.jl","text":"","category":"section"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"Rasters.jl also supports plotting with Makie.jl as of version 0.5.3. If using an older version we can write a method for convert_arguments to convert a Raster into a format that can be plotted by Makie.jl. For more information on implementing type recipes for plotting custom types in Makie.jl see the Makie.jl plot recipes documentation. The convert_arguments method extracts the longitude and latitude dims from a Raster as well as the values for the chosen variable. The SurfaceLike argument converts the data so we can use the contourf, heatmap or other SurfaceLike plotting functions.","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"using GeoMakie, CairoMakie\n\nfunction Makie.convert_arguments(P::SurfaceLike, rs::Raster)\n\n    lon, lat = collect(lookup(rs, X)), collect(lookup(rs, Y))\n    plot_var = Matrix(rs[:, :])\n\n    return convert_arguments(P, lon, lat, plot_var)\n\nend","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"info: convert_arguments method\nThis is a specific method for convert_arguments written for this data. To plot different data (or other parts of this data, e.g. depth-latitude) that are in Raster data structures, more methods need to be added to convert_arguments that extract the desired parts of the Raster.","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"Now we can plot a Raster onto a GeoAxis and take advantage of the extra features GeoMakie.jl offers, like map projections (see the GeoMakie.jl documentation for more information about available projections and how to set them), automatic axis limits and coastlines.","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"date = lookup(converted_stack, Ti)[1] # get the date from the `Raster`\ndepth = 0.0                           # choose a depth to look at the ocean temperature\nfig = Figure(size = (800, 500))\nax = GeoAxis(fig[1, 1];\n             xlabel = \"Longitude\",\n             ylabel = \"Latitude\",\n             title = \"Ocean conservative temperature at depth $(depth)m\",\n             subtitle = \"$date\",\n             coastlines = true)\ncp = CairoMakie.contourf!(ax, converted_stack[:Θ][Z(Near(depth)), Ti(At(date))];\n                          colormap = :balance)\nColorbar(fig[2, 1], cp; label = \"Θ (ᵒC)\", vertical = false, flipaxis = false)\nfig","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"","category":"page"},{"location":"literated/ocean_variable_conversion/","page":"Converting ocean variables","title":"Converting ocean variables","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#OceanRasterConversions.jl-documentation","page":"Home","title":"OceanRasterConversions.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rasters.jl provides excellent methods for reading, analysing and plotting for geospatial data. This package contains modules that are useful for analysing oceanic data (either model output or gridded observations) and is designed to be used in conjunction with Rasters.jl. The modules are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OceanVariableConversions, conversion and computation (using TEOS-10) of ocean variables that are Raster data structures; and\nRasterHistograms, empirical distribution fitting for Raster data structures aiming to provide functionality similar to python's xhistogram for xarray in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If there are any bugs and/or feature request please raise an issue on the GitHub page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Info\nThis package assumes that the missingval = missing in the Raster, RasterStack or RasterSeries. By default missingval = missing in Rasters.jl, so as long as the missingval has not been changed the modules in this package will work.","category":"page"}]
}
